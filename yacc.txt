%{
   /*
   Author1: Fred Aklamanu (fred.aklamanu@telecom-sudparis.eu)
   Author2: Saurabh Sharma (saurabh.sharma@telecom-sudparis.eu)
   Date:    09/06/2015
   Version : 5.0
   Course:  CSC 7201 (Computing Project)
   Description: This is the code for yacc that reads the tokens generated by lex based on a defined grammar.
   It creates a tree data structure and add these tokens to the tree with some additional information.
   This additional information comprises of total number of cycles and function count/jump count to separate different function calls or jumps with same name.
   */
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#define YYSTYPE char*
# define YYDEBUG 1
//extern int yylineno ;
extern char * yytext ;
extern int yylex();
extern int yyparse();
extern FILE *yyin;
void yyerror(const char *str);
int instcount,functcount;
int cjcount=0;
int ujcount=0;
int fcount=0;
int cycles;
int numberofcycles ( char instruction[10] );
/* Below is the definition of the tree to store the string data(data 1), cycle count(data2),function/jump count(data 3),
   status is used to insert the node on the left or right */
struct Node* root = NULL;
struct Node {
char * data1;
int data2;
int status;
int data3;
struct Node *left;
struct Node *right;
};

/*
   Function   : Insert
   Description: The Insert Procedure is used to insert a node to the tree
   Parameters : Pointer to the root node,string data(data 1), cycle count(data2),status,function/jump count(data 3)
   Returns     : The pointer to the root node
*/

struct Node* Insert(struct Node *root,char * data1,int data2,int status, int data3) {
if(root == NULL) {
root =(struct Node *)malloc(sizeof(struct Node));
root->data1 = data1;
root->data2 = data2;
root->data3 = data3;
root->left = root->right = NULL;
}
else if(status==1)//if atatus is 1 insert the node to the left sub tree
{
root->left = Insert(root->left,data1,data2,status,data3);

}
else
{
root->right = Insert(root->right,data1,data2,status,data3); //else insert to the right sub tree
}
return root;
}

/*
   Function   : Preorder
   Description: The Preorder Procedure is used to visit nodes of  the tree in Preorder (root,left,right)
   Parameters : Pointer to the root node,string data(data 1), cycle count(data2),status,function/jump count(data 3)
   Returns     : The pointer to the root node
*/


void Preorder(struct Node *root) {
// base condition for recursion

// if tree/sub-tree is empty, return and exit
if(root == NULL) return;

/*Below if statements are used to print only those fields of the node that are non zero and combine data to the their respect counts
Example printf,2,1,3 indicates 2 (cycles), 1(added to the left), 3 (printf is the 3rd function call). This will be printed as printf3
*/
if (((*root).left!=NULL)&&((*root).left->data3==0)&&(root->data3!=0))
{
printf("%s%d,%s,%d\n ",root->data1,root->data3,(*root).left->data1,(*root).left->data2);
}
else if (((*root).left!=NULL)&&((*root).left->data3!=0)&&(root->data3==0))
{
printf("%s,%s%d,%d\n ",root->data1,(*root).left->data1,(*root).left->data3,(*root).left->data2);
}
if(((*root).left!=NULL)&&((*root).left->data3!=0)&&(root->data3!=0))
{
printf("%s%d,%s%d,%d\n ",root->data1,root->data3,(*root).left->data1,(*root).left->data3,(*root).left->data2);
}
if(((*root).left!=NULL)&&((*root).left->data3==0)&&(root->data3==0))
{
printf("%s,%s,%d\n ",root->data1,(*root).left->data1,(*root).left->data2);
}


Preorder(root->left); 		// Visit left subtree
Preorder(root->right); 		// Visit right subtree
}



%}
%token  Function_Label Normal_Instruction Conditional_Jump_Label Unconditional_Jump_Label Function_Call_Label Normal_Label Return Colon
%%
// Below is the grammer for Yacc
prog : function_list | label_list function_list;


function_list : Fcontent
              | Fcontent function_list


Fcontent :  Funct_Label  Inst_list  ;

Funct_Label  : Function_Label Colon     {fcount=0;cjcount=0;ujcount=0;strcat($1,",label");root = Insert( root,$1,instcount,1,0);};


label_list : Norm_Label | Norm_Label label_list;

Inst_list: instr
           | instr Inst_list  ;

instr:              Norm_Label                          { root = Insert( root, $1,instcount,1,0); instcount=0; }
                    |Normal_Instruction			{ cycles=numberofcycles($1) ;instcount=instcount+cycles;}
		    | Conditional_Jump_Label 		{ cjcount++; strcat($1,",CJL");root = Insert( root,"Cjump",instcount,1,cjcount);instcount=0;root = Insert(root,$1,instcount,1,cjcount); }
		    | Unconditional_Jump_Label 		{ ujcount++; strcat($1,",UjL");root = Insert( root,"Ujump",instcount,1,ujcount);instcount=0;root = Insert(root,$1,instcount,1,ujcount); }
		    | Function_Call_Label		{ fcount++;root = Insert( root, $1,instcount,1,fcount); instcount=0; }
		    | Return                            { root = Insert( root,"RET",instcount,1,0);instcount=0; }
		    ;

Norm_Label: Normal_Label Colon                      //     { printf("Normal Label found: %s\n", $1); };
%%


/*
   Function   : numberofcycles
   Description: The numberofcycles procedure is used to count the number of cycles required to execute the instruction.
                It matches the instruction in the .txt file (cycledata) and reads the no of cycles
   Parameters : instruction as a string
   Returns     : Cycle count
*/


int numberofcycles ( char instruction[10] )
{

  char *split;
  char *token;
   char *token1;
  char delimiter[1] = ",";
  char delimiter1[1] = "	";
  char  found[10];
  int cycles = 0;
  char  temp[10];
  int flag=0;
  FILE * fhandler;
  fhandler = fopen("cyclesdata", "r");
  if ( fhandler == NULL)
  {
    printf("File doesn't exist or cannot be opened\n");
  }

      while ( !feof( fhandler ) )
      {

	fgets(found, 10, fhandler);
	strcpy(temp,found);

	token = strtok(found, delimiter);	// strtok returns NULL if no more tokens


	token1 = strtok(instruction, delimiter1);

	if (strcmp(token, token1) == 0 )
	{
	flag=1;

	  split  = strtok(temp, ",");

          split = strtok(NULL, ",");

	 cycles += atoi(split);
	}



}
if (flag)
      return cycles;
      else return 1;
}

void yyerror(const char *str)
{
	fprintf(stderr,"error: %s\n",str);
}

int yywrap()
{
	return 1;
}

main(argc,argv)
    int argc ;
    char **argv ;
{
if (argc > 1) {
FILE *file;
file = fopen(argv[1], "r" ) ;
if (!file) {
fprintf(stderr,"could not open %s\n",argv[1]);
}
yyin=file;
}
do {
		yyparse();
	} while (!feof(yyin));
	//printf("final tree\n");
	Preorder(root);
}
